<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; gauNEGF  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Examples and Tutorials" href="../examples/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            gauNEGF
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../theory/index.html">Theory Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples and Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="#core-modules">Core Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#negf-base-class">NEGF Base Class</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.scf.NEGF"><code class="docutils literal notranslate"><span class="pre">NEGF</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.F"><code class="docutils literal notranslate"><span class="pre">NEGF.F</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.P"><code class="docutils literal notranslate"><span class="pre">NEGF.P</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.S"><code class="docutils literal notranslate"><span class="pre">NEGF.S</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.fermi"><code class="docutils literal notranslate"><span class="pre">NEGF.fermi</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.nelec"><code class="docutils literal notranslate"><span class="pre">NEGF.nelec</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.FockToP"><code class="docutils literal notranslate"><span class="pre">NEGF.FockToP()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.PMix"><code class="docutils literal notranslate"><span class="pre">NEGF.PMix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.PToFock"><code class="docutils literal notranslate"><span class="pre">NEGF.PToFock()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.SCF"><code class="docutils literal notranslate"><span class="pre">NEGF.SCF()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.__init__"><code class="docutils literal notranslate"><span class="pre">NEGF.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.getHOMOLUMO"><code class="docutils literal notranslate"><span class="pre">NEGF.getHOMOLUMO()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.getSigma"><code class="docutils literal notranslate"><span class="pre">NEGF.getSigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.runDFT"><code class="docutils literal notranslate"><span class="pre">NEGF.runDFT()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.saveMAT"><code class="docutils literal notranslate"><span class="pre">NEGF.saveMAT()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.setContacts"><code class="docutils literal notranslate"><span class="pre">NEGF.setContacts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.setDen"><code class="docutils literal notranslate"><span class="pre">NEGF.setDen()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.setFock"><code class="docutils literal notranslate"><span class="pre">NEGF.setFock()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.setSigma"><code class="docutils literal notranslate"><span class="pre">NEGF.setSigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.setVoltage"><code class="docutils literal notranslate"><span class="pre">NEGF.setVoltage()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.updateN"><code class="docutils literal notranslate"><span class="pre">NEGF.updateN()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scf.NEGF.writeChk"><code class="docutils literal notranslate"><span class="pre">NEGF.writeChk()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#energy-dependent-negf">Energy-Dependent NEGF</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.scfE.NEGFE"><code class="docutils literal notranslate"><span class="pre">NEGFE</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.FockToP"><code class="docutils literal notranslate"><span class="pre">NEGFE.FockToP()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.PToFock"><code class="docutils literal notranslate"><span class="pre">NEGFE.PToFock()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.getSigma"><code class="docutils literal notranslate"><span class="pre">NEGFE.getSigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.integralCheck"><code class="docutils literal notranslate"><span class="pre">NEGFE.integralCheck()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.setContact1D"><code class="docutils literal notranslate"><span class="pre">NEGFE.setContact1D()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.setContactBethe"><code class="docutils literal notranslate"><span class="pre">NEGFE.setContactBethe()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.setIntegralLimits"><code class="docutils literal notranslate"><span class="pre">NEGFE.setIntegralLimits()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.setSigma"><code class="docutils literal notranslate"><span class="pre">NEGFE.setSigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.scfE.NEGFE.setVoltage"><code class="docutils literal notranslate"><span class="pre">NEGFE.setVoltage()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#density-module">Density Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.DOSg"><code class="docutils literal notranslate"><span class="pre">DOSg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.Gr"><code class="docutils literal notranslate"><span class="pre">Gr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.bisectFermi"><code class="docutils literal notranslate"><span class="pre">bisectFermi()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.calcFermi"><code class="docutils literal notranslate"><span class="pre">calcFermi()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.calcFermiBisect"><code class="docutils literal notranslate"><span class="pre">calcFermiBisect()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.calcFermiMuller"><code class="docutils literal notranslate"><span class="pre">calcFermiMuller()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.calcFermiSecant"><code class="docutils literal notranslate"><span class="pre">calcFermiSecant()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.density"><code class="docutils literal notranslate"><span class="pre">density()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.densityComplex"><code class="docutils literal notranslate"><span class="pre">densityComplex()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.densityComplexTrap"><code class="docutils literal notranslate"><span class="pre">densityComplexTrap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.densityGrid"><code class="docutils literal notranslate"><span class="pre">densityGrid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.densityGridTrap"><code class="docutils literal notranslate"><span class="pre">densityGridTrap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.densityReal"><code class="docutils literal notranslate"><span class="pre">densityReal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.fermi"><code class="docutils literal notranslate"><span class="pre">fermi()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.getANTPoints"><code class="docutils literal notranslate"><span class="pre">getANTPoints()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.getFermi1DContact"><code class="docutils literal notranslate"><span class="pre">getFermi1DContact()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.getFermiContact"><code class="docutils literal notranslate"><span class="pre">getFermiContact()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.integralFit"><code class="docutils literal notranslate"><span class="pre">integralFit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.integralFitNEGF"><code class="docutils literal notranslate"><span class="pre">integralFitNEGF()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.density.integratePoints"><code class="docutils literal notranslate"><span class="pre">integratePoints()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#transport-module">Transport Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.DOS"><code class="docutils literal notranslate"><span class="pre">DOS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.DOSE"><code class="docutils literal notranslate"><span class="pre">DOSE()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.cohTrans"><code class="docutils literal notranslate"><span class="pre">cohTrans()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.cohTransE"><code class="docutils literal notranslate"><span class="pre">cohTransE()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.cohTransSpin"><code class="docutils literal notranslate"><span class="pre">cohTransSpin()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.cohTransSpinE"><code class="docutils literal notranslate"><span class="pre">cohTransSpinE()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.current"><code class="docutils literal notranslate"><span class="pre">current()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.currentE"><code class="docutils literal notranslate"><span class="pre">currentE()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.currentF"><code class="docutils literal notranslate"><span class="pre">currentF()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.transport.currentSpin"><code class="docutils literal notranslate"><span class="pre">currentSpin()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#contact-models">Contact Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#bethe-lattice">Bethe Lattice</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB"><code class="docutils literal notranslate"><span class="pre">surfGB</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.cVecs"><code class="docutils literal notranslate"><span class="pre">surfGB.cVecs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.latVecs"><code class="docutils literal notranslate"><span class="pre">surfGB.latVecs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.indsLists"><code class="docutils literal notranslate"><span class="pre">surfGB.indsLists</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.dirLists"><code class="docutils literal notranslate"><span class="pre">surfGB.dirLists</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.nIndLists"><code class="docutils literal notranslate"><span class="pre">surfGB.nIndLists</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.gList"><code class="docutils literal notranslate"><span class="pre">surfGB.gList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.constructMat"><code class="docutils literal notranslate"><span class="pre">surfGB.constructMat()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.genNeighbors"><code class="docutils literal notranslate"><span class="pre">surfGB.genNeighbors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.getSigma"><code class="docutils literal notranslate"><span class="pre">surfGB.getSigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.readBetheParams"><code class="docutils literal notranslate"><span class="pre">surfGB.readBetheParams()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.runAllTests"><code class="docutils literal notranslate"><span class="pre">surfGB.runAllTests()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.setF"><code class="docutils literal notranslate"><span class="pre">surfGB.setF()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.sigma"><code class="docutils literal notranslate"><span class="pre">surfGB.sigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.sigmaTot"><code class="docutils literal notranslate"><span class="pre">surfGB.sigmaTot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.testDDInteraction"><code class="docutils literal notranslate"><span class="pre">surfGB.testDDInteraction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.testDOrbitalFunctions"><code class="docutils literal notranslate"><span class="pre">surfGB.testDOrbitalFunctions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.testDOrbitalSymmetry"><code class="docutils literal notranslate"><span class="pre">surfGB.testDOrbitalSymmetry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.testHoppingPhysics"><code class="docutils literal notranslate"><span class="pre">surfGB.testHoppingPhysics()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.testPDInteraction"><code class="docutils literal notranslate"><span class="pre">surfGB.testPDInteraction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGB.updateFermi"><code class="docutils literal notranslate"><span class="pre">surfGB.updateFermi()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt"><code class="docutils literal notranslate"><span class="pre">surfGBAt</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.NN"><code class="docutils literal notranslate"><span class="pre">surfGBAt.NN</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.sigmaKprev"><code class="docutils literal notranslate"><span class="pre">surfGBAt.sigmaKprev</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.Eprev"><code class="docutils literal notranslate"><span class="pre">surfGBAt.Eprev</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.fermi"><code class="docutils literal notranslate"><span class="pre">surfGBAt.fermi</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.F"><code class="docutils literal notranslate"><span class="pre">surfGBAt.F</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.S"><code class="docutils literal notranslate"><span class="pre">surfGBAt.S</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.DOS"><code class="docutils literal notranslate"><span class="pre">surfGBAt.DOS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.__init__"><code class="docutils literal notranslate"><span class="pre">surfGBAt.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.calcFermi"><code class="docutils literal notranslate"><span class="pre">surfGBAt.calcFermi()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.setF"><code class="docutils literal notranslate"><span class="pre">surfGBAt.setF()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.sigma"><code class="docutils literal notranslate"><span class="pre">surfGBAt.sigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.sigmaK"><code class="docutils literal notranslate"><span class="pre">surfGBAt.sigmaK()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.sigmaTot"><code class="docutils literal notranslate"><span class="pre">surfGBAt.sigmaTot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGBethe.surfGBAt.updateH"><code class="docutils literal notranslate"><span class="pre">surfGBAt.updateH()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#d-chain">1D Chain</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.surfG1D.surfG"><code class="docutils literal notranslate"><span class="pre">surfG</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.F"><code class="docutils literal notranslate"><span class="pre">surfG.F</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.S"><code class="docutils literal notranslate"><span class="pre">surfG.S</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.X"><code class="docutils literal notranslate"><span class="pre">surfG.X</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.tauList"><code class="docutils literal notranslate"><span class="pre">surfG.tauList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.stauList"><code class="docutils literal notranslate"><span class="pre">surfG.stauList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.aList"><code class="docutils literal notranslate"><span class="pre">surfG.aList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.aSList"><code class="docutils literal notranslate"><span class="pre">surfG.aSList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.bList"><code class="docutils literal notranslate"><span class="pre">surfG.bList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.bSList"><code class="docutils literal notranslate"><span class="pre">surfG.bSList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.gPrev"><code class="docutils literal notranslate"><span class="pre">surfG.gPrev</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.__init__"><code class="docutils literal notranslate"><span class="pre">surfG.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.denFunc"><code class="docutils literal notranslate"><span class="pre">surfG.denFunc()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.densityGrid"><code class="docutils literal notranslate"><span class="pre">surfG.densityGrid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.g"><code class="docutils literal notranslate"><span class="pre">surfG.g()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.setContacts"><code class="docutils literal notranslate"><span class="pre">surfG.setContacts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.setF"><code class="docutils literal notranslate"><span class="pre">surfG.setF()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.sigma"><code class="docutils literal notranslate"><span class="pre">surfG.sigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfG1D.surfG.sigmaTot"><code class="docutils literal notranslate"><span class="pre">surfG.sigmaTot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#constant-self-energy">Constant Self Energy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.surfGTester.surfGTest"><code class="docutils literal notranslate"><span class="pre">surfGTest</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGTester.surfGTest.setF"><code class="docutils literal notranslate"><span class="pre">surfGTest.setF()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGTester.surfGTest.sigma"><code class="docutils literal notranslate"><span class="pre">surfGTest.sigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauNEGF.surfGTester.surfGTest.sigmaTot"><code class="docutils literal notranslate"><span class="pre">surfGTest.sigmaTot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#matrix-tools">Matrix Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.matTools.formSigma"><code class="docutils literal notranslate"><span class="pre">formSigma()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.matTools.getDen"><code class="docutils literal notranslate"><span class="pre">getDen()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.matTools.getEnergies"><code class="docutils literal notranslate"><span class="pre">getEnergies()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.matTools.getFock"><code class="docutils literal notranslate"><span class="pre">getFock()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#gauNEGF.matTools.storeDen"><code class="docutils literal notranslate"><span class="pre">storeDen()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">gauNEGF</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h1>
<p>This section provides detailed API documentation for all gauNEGF modules.</p>
</section>
<section id="core-modules">
<h1>Core Modules<a class="headerlink" href="#core-modules" title="Permalink to this heading"></a></h1>
<section id="negf-base-class">
<h2>NEGF Base Class<a class="headerlink" href="#negf-base-class" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.scf"></span><p>Self-consistent field (SCF) implementation for Non-Equilibrium Green’s Function calculations.</p>
<p>This module provides the base NEGF class for performing self-consistent DFT+NEGF
calculations using Gaussian quantum chemistry package. It implements the energy-independent
self-energy approach developed by Damle et al., which provides an efficient approximation
for molecular transport calculations. The module handles:</p>
<blockquote>
<div><ul class="simple">
<li><p>Integration with Gaussian for DFT calculations</p></li>
<li><p>SCF convergence with Pulay mixing [2]</p></li>
<li><p>Contact self-energy calculations</p></li>
<li><p>Voltage bias and electric field effects</p></li>
<li><p>Spin-polarized calculations</p></li>
</ul>
</div></blockquote>
<p>The implementation follows the standard NEGF formalism where the density matrix
is calculated self-consistently with the Fock matrix from Gaussian DFT calculations.
Convergence is accelerated using the direct inversion in the iterative subspace (DIIS)
method developed by Pulay [2]. The core NEGF-DFT implementation is based on the
ANT.Gaussian approach developed by Palacios et al. [3], which pioneered the integration
of NEGF with Gaussian-based DFT calculations.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Damle, P., Ghosh, A. W., &amp; Datta, S. (2002). First-principles analysis of molecular</dt><dd><p>conduction using quantum chemistry software. Chemical Physics, 281(2-3), 171-187.
DOI: 10.1016/S0301-0104(02)00496-2</p>
</dd>
<dt>[2] Pulay, P. (1980). Convergence acceleration of iterative sequences. The case of SCF</dt><dd><p>iteration. Chemical Physics Letters, 73(2), 393-398.
DOI: 10.1016/0009-2614(80)80396-4</p>
</dd>
<dt>[3] Palacios, J. J., Pérez-Jiménez, A. J., Louis, E., &amp; Vergés, J. A. (2002).</dt><dd><p>Fullerene-based molecular nanobridges: A first-principles study.
Physical Review B, 66(3), 035322.
DOI: 10.1103/PhysRevB.66.035322</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gauNEGF.scf.</span></span><span class="sig-name descname"><span class="pre">NEGF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'chkbasis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'b3pw91'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullSCF</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">route</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nPulay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Non-Equilibrium Green’s Function calculator integrated with Gaussian DFT.</p>
<p>This class implements the energy-independent NEGF approach developed by Damle et al. [1]
for efficient molecular transport calculations. It manages the self-consistent field
calculation between NEGF transport calculations and DFT electronic structure calculations
using Gaussian.</p>
<p>The energy-independent approximation assumes constant self-energies,
which significantly reduces computational cost while maintaining accuracy for many
molecular systems.</p>
<p>The class handles:
- Interaction with Gaussian
- Management of density and Fock matrices
- Pulay mixing for convergence [2]
- Constant (energy-independent) contact self-energies
- Voltage bias effects</p>
<p>For energy-dependent calculations, see the NEGFE subclass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<em>str</em>) – Base filename for Gaussian input/output files (without extension)</p></li>
<li><p><strong>basis</strong> (<em>str</em><em>, </em><em>optional</em>) – Gaussian basis set name (default: ‘chkbasis’)</p></li>
<li><p><strong>func</strong> (<em>str</em><em>, </em><em>optional</em>) – DFT functional to use (default: ‘b3pw91’)</p></li>
<li><p><strong>spin</strong> (<em>{'r'</em><em>, </em><em>'u'</em><em>, </em><em>'ro'</em><em>, </em><em>'g'}</em><em>, </em><em>optional</em>) – Spin configuration:
- ‘r’: restricted
- ‘u’: unrestricted
- ‘ro’: restricted open-shell
- ‘g’: generalized open-shell (non-collinear)
(default: ‘r’)</p></li>
<li><p><strong>fullSCF</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to run full SCF or use Harris approximation (default: True)</p></li>
<li><p><strong>route</strong> (<em>str</em><em>, </em><em>optional</em>) – Additional Gaussian route commands (default: ‘’)</p></li>
<li><p><strong>nPulay</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of previous iterations to use in Pulay mixing (default: 4)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.F">
<span class="sig-name descname"><span class="pre">F</span></span><a class="headerlink" href="#gauNEGF.scf.NEGF.F" title="Permalink to this definition"></a></dt>
<dd><p>Fock matrix in eV</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.P">
<span class="sig-name descname"><span class="pre">P</span></span><a class="headerlink" href="#gauNEGF.scf.NEGF.P" title="Permalink to this definition"></a></dt>
<dd><p>Density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.S">
<span class="sig-name descname"><span class="pre">S</span></span><a class="headerlink" href="#gauNEGF.scf.NEGF.S" title="Permalink to this definition"></a></dt>
<dd><p>Overlap matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.fermi">
<span class="sig-name descname"><span class="pre">fermi</span></span><a class="headerlink" href="#gauNEGF.scf.NEGF.fermi" title="Permalink to this definition"></a></dt>
<dd><p>Fermi energy in eV</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.nelec">
<span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#gauNEGF.scf.NEGF.nelec" title="Permalink to this definition"></a></dt>
<dd><p>Number of electrons</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Damle, P., Ghosh, A. W., &amp; Datta, S. (2002). First-principles analysis of molecular</dt><dd><p>conduction using quantum chemistry software. Chemical Physics, 281(2-3), 171-187.
DOI: 10.1016/S0301-0104(02)00496-2</p>
</dd>
</dl>
<p>[2] Pulay, P. (1980). DOI: 10.1016/0009-2614(80)80396-4</p>
<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.FockToP">
<span class="sig-name descname"><span class="pre">FockToP</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.FockToP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.FockToP" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density matrix from Fock matrix using energy-independent approach.</p>
<p>This method implements the energy-independent density matrix calculation from
Damle et al. (2002). By assuming constant self-energies, the density matrix
can be calculated analytically without energy integration, significantly
reducing computational cost.</p>
<p>The method:
1. Transforms Fock and Gamma matrices to orthogonal basis
2. Diagonalizes the transformed Fock matrix
3. Updates Fermi energy if needed
4. Calculates density matrix analytically
5. Transforms back to non-orthogonal basis</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(eigenvalues, occupations) sorted by energy</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Damle, P., Ghosh, A. W., &amp; Datta, S. (2002). First-principles analysis of molecular</dt><dd><p>conduction using quantum chemistry software. Chemical Physics, 281(2-3), 171-187.
DOI: 10.1016/S0301-0104(02)00496-2</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.PMix">
<span class="sig-name descname"><span class="pre">PMix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">damping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pulay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.PMix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.PMix" title="Permalink to this definition"></a></dt>
<dd><p>Mix old and new density matrices using damping or Pulay DIIS method [2].</p>
<p>The Pulay mixing method (also known as DIIS - Direct Inversion in the
Iterative Subspace) uses information from previous iterations to predict
the optimal density matrix. This method is particularly effective for
systems with challenging convergence behavior, and closely follows ANT.Gaussian approaches.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>damping</strong> (<em>float</em>) – Mixing parameter between 0 and 1</p></li>
<li><p><strong>Pulay</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use Pulay mixing (default: False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(RMSDP, MaxDP) - RMS and maximum density matrix differences</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Pulay DIIS method [2] minimizes the error in the iterative subspace
spanned by previous density matrices. This often provides faster and more
stable convergence compared to simple damping, especially for systems
with strong electron correlation or near degeneracies [3].</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Pulay, P. (1980). DOI: 10.1016/0009-2614(80)80396-4</p>
</aside>
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Palacios, J. J., et al. (2002). DOI: 10.1103/PhysRevB.66.035322</p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.PToFock">
<span class="sig-name descname"><span class="pre">PToFock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.PToFock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.PToFock" title="Permalink to this definition"></a></dt>
<dd><p>Calculate new Fock matrix from current density matrix using Gaussian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Energy difference from previous iteration</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.SCF">
<span class="sig-name descname"><span class="pre">SCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.SCF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.SCF" title="Permalink to this definition"></a></dt>
<dd><p>Run self-consistent field calculation until convergence.</p>
<p>The SCF cycle alternates between Fock matrix construction and density matrix
updates until convergence is reached. Convergence acceleration is achieved
through either simple damping or Pulay DIIS mixing [2]. The Pulay method
is applied every nPulay iterations (where nPulay is set in __init__) [3].</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Palacios, J. J., et al. (2002). DOI: 10.1103/PhysRevB.66.035322</p>
</aside>
</aside>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for energy and density (default: 1e-5)</p></li>
<li><p><strong>damping</strong> (<em>float</em><em>, </em><em>optional</em>) – Mixing parameter between 0 and 1 (default: 0.02)</p></li>
<li><p><strong>maxcycles</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of SCF cycles (default: 100)</p></li>
<li><p><strong>checkpoint</strong> (<em>bool</em><em>, </em><em>optional</em>) – Save density matrix at each iteration and load if job interrupted (default: True)</p></li>
<li><p><strong>pulay</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use Pulay DIIS mixing [2] (default: True)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(count, PP, TotalE) - cycle number, number of electrons, and DFT energy at each cycle</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Convergence is determined by three criteria:
1. Energy change (dE)
2. RMS density matrix difference (RMSDP)
3. Maximum density matrix difference (MaxDP)</p>
<p>All three must be below the convergence threshold.</p>
<p>The Pulay DIIS method [2] is applied every nPulay iterations when enabled,
which often provides faster and more stable convergence compared to simple
damping, especially for challenging systems.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Pulay, P. (1980). DOI: 10.1016/0009-2614(80)80396-4</p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'chkbasis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'b3pw91'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullSCF</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">route</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nPulay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize NEGF calculator and run initial DFT calculation.</p>
<p>Sets up the calculator with specified parameters and runs an initial
DFT calculation using Gaussian to obtain the starting Fock and
overlap matrices.</p>
<p>Parameters are documented in class docstring.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.getHOMOLUMO">
<span class="sig-name descname"><span class="pre">getHOMOLUMO</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.getHOMOLUMO"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.getHOMOLUMO" title="Permalink to this definition"></a></dt>
<dd><p>Calculate HOMO and LUMO energies.</p>
<p>Diagonalizes the Fock matrix in orthogonalized basis to get
orbital energies, then identifies HOMO and LUMO based on
electron occupation and spin configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array of [HOMO, LUMO] energies in eV</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.getSigma">
<span class="sig-name descname"><span class="pre">getSigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.getSigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.getSigma" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.runDFT">
<span class="sig-name descname"><span class="pre">runDFT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullSCF</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.runDFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.runDFT" title="Permalink to this definition"></a></dt>
<dd><p>Run DFT calculation using Gaussian.</p>
<p>Performs either a full SCF calculation or generates an initial Harris
guess using Gaussian. Updates the Fock matrix and orbital indices
after completion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fullSCF</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, runs full SCF to convergence.
If False, uses Harris guess only. (default: True)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Attempts to load from checkpoint file first</p></li>
<li><p>Falls back to full calculation if checkpoint fails</p></li>
<li><p>Updates self.F and self.locs with new Fock matrix</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.saveMAT">
<span class="sig-name descname"><span class="pre">saveMAT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'out.mat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.saveMAT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.saveMAT" title="Permalink to this definition"></a></dt>
<dd><p>Save calculation results to MATLAB format file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matfile</strong> (<em>str</em><em>, </em><em>optional</em>) – Output filename (default: “out.mat”)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Fock matrix in orthogonalized basis</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.setContacts">
<span class="sig-name descname"><span class="pre">setContacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lContact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rContact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.setContacts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.setContacts" title="Permalink to this definition"></a></dt>
<dd><p>Set contact atoms and get corresponding orbital indices.</p>
<p>Identifies the orbital indices corresponding to the specified
contact atoms. If no contacts specified, uses all orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lContact</strong> (<em>int</em><em> or </em><em>array-like</em><em>, </em><em>optional</em>) – Atom number(s) for left contact. None means all atoms. (default: None)</p></li>
<li><p><strong>rContact</strong> (<em>int</em><em> or </em><em>array-like</em><em>, </em><em>optional</em>) – Atom number(s) for right contact. None means all atoms. (default: None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(left_orbital_indices, right_orbital_indices)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of ndarrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.setDen">
<span class="sig-name descname"><span class="pre">setDen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.setDen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.setDen" title="Permalink to this definition"></a></dt>
<dd><p>Set the density matrix and update dependent quantities.</p>
<p>Updates the density matrix, stores it in Gaussian format,
recalculates the number of electrons, and updates the Fock matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>P</strong> (<em>ndarray</em>) – New density matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.setFock">
<span class="sig-name descname"><span class="pre">setFock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.setFock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.setFock" title="Permalink to this definition"></a></dt>
<dd><p>Set the Fock matrix, converting from eV to atomic units.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix in Hartree units</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.setSigma">
<span class="sig-name descname"><span class="pre">setSigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lContact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rContact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0</span> <span class="pre">-</span> <span class="pre">0.1j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.setSigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.setSigma" title="Permalink to this definition"></a></dt>
<dd><p>Set self-energies for left and right contacts.</p>
<p>Configures the contact self-energies, handling various input formats
and spin configurations. Self-energies can be scalar, vector, or matrix,
with automatic handling of spin degrees of freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lContact</strong> (<em>array-like</em>) – Atom numbers for left contact, all atoms if None (default: None)</p></li>
<li><p><strong>rContact</strong> (<em>array-like</em>) – Atom numbers for right contact, all atoms if None (default: None)</p></li>
<li><p><strong>sig</strong> (<em>scalar</em><em> or </em><em>array-like</em><em>, </em><em>optional</em>) – Self-energy for left contact. Can be:
- scalar: same value for all orbitals
- vector: one value per orbital
- matrix: full self-energy matrix
(default: -0.1j)</p></li>
<li><p><strong>sig2</strong> (<em>scalar</em><em>, </em><em>array-like</em><em>, or </em><em>None</em><em>, </em><em>optional</em>) – Self-energy for right contact. If None, uses sig.
Same format options as sig. (default: None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Left and right contact orbital indices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Handles spin configurations (‘r’, ‘u’, ‘ro’, ‘g’)</p></li>
<li><p>Automatically expands scalar/vector inputs to full matrices</p></li>
<li><p>Verifies matrix dimensions match Fock matrix</p></li>
<li><p>Updates self.sigma1, self.sigma2, self.sigma12</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If matrix dimensions don’t match or invalid input format</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.setVoltage">
<span class="sig-name descname"><span class="pre">setVoltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.setVoltage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.setVoltage" title="Permalink to this definition"></a></dt>
<dd><p>Set voltage bias and Fermi energy, updating electric field.</p>
<p>Applies a voltage bias between contacts and updates the chemical
potentials and electric field. Can optionally set the Fermi energy
and integration limits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qV</strong> (<em>float</em>) – Voltage bias in eV</p></li>
<li><p><strong>fermi</strong> (<em>float</em><em>, </em><em>optional</em>) – Fermi energy in eV. If not provided, will be calculated or
use existing value (default: np.nan)</p></li>
<li><p><strong>Emin</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum energy for integration in eV (default: None)</p></li>
<li><p><strong>Eminf</strong> (<em>float</em><em>, </em><em>optional</em>) – Lower bound energy in eV (default: None)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Requires contacts to be set first</p></li>
<li><p>Updates chemical potentials as fermi ± qV/2</p></li>
<li><p>Calculates and applies electric field between contacts</p></li>
<li><p>If fermi not provided, uses (HOMO+LUMO)/2 for initial guess</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.updateN">
<span class="sig-name descname"><span class="pre">updateN</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.updateN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.updateN" title="Permalink to this definition"></a></dt>
<dd><p>Update the total number of electrons from the density matrix.</p>
<p>Calculates the number of electrons by tracing the product of
the density and overlap matrices. For restricted calculations,
multiplies by 2 to account for spin degeneracy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Total number of electrons</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scf.NEGF.writeChk">
<span class="sig-name descname"><span class="pre">writeChk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scf.html#NEGF.writeChk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scf.NEGF.writeChk" title="Permalink to this definition"></a></dt>
<dd><p>Write current state to Gaussian checkpoint file.</p>
</dd></dl>

</dd></dl>

</section>
<section id="energy-dependent-negf">
<h2>Energy-Dependent NEGF<a class="headerlink" href="#energy-dependent-negf" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.scfE"></span><p>Energy-dependent extensions to the NEGF class for quantum transport calculations.</p>
<p>This module extends the base NEGF class to handle energy-dependent self-energies,
temperature effects, and advanced Fermi energy search methods. It provides support
for Bethe lattice and 1D chain contacts [1] with proper energy integration.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Jacob, D. &amp; Palacios, J. J. Chem. Phys. 134, 044118 (2011)</p>
</aside>
</aside>
<dl class="py class">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gauNEGF.scfE.</span></span><span class="sig-name descname"><span class="pre">NEGFE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'chkbasis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'b3pw91'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullSCF</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">route</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nPulay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#gauNEGF.scf.NEGF" title="gauNEGF.scf.NEGF"><code class="xref py py-class docutils literal notranslate"><span class="pre">NEGF</span></code></a></p>
<p>Extended NEGF class with energy-dependent self-energies and temperature effects.</p>
<p>This class extends the base NEGF implementation to handle:
- Energy-dependent contact self-energies
- Finite temperature effects
- Advanced Fermi energy search methods
- Integration methods for the density matrix</p>
<p>Inherits all attributes and methods from NEGF class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.FockToP">
<span class="sig-name descname"><span class="pre">FockToP</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.FockToP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.FockToP" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density matrix using energy-dependent integration.</p>
<p>Performs complex contour integration for the equilibrium part
and real axis integration for the non-equilibrium part.
Updates Fermi energy using specified method if required.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(energies, occupations) - Sorted eigenvalues and occupations</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.PToFock">
<span class="sig-name descname"><span class="pre">PToFock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.PToFock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.PToFock" title="Permalink to this definition"></a></dt>
<dd><p>Calculate new Fock matrix and update surfG object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Energy difference from previous iteration</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.getSigma">
<span class="sig-name descname"><span class="pre">getSigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.getSigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.getSigma" title="Permalink to this definition"></a></dt>
<dd><p>Get contact self-energies at specified energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>E</strong> (<em>float</em>) – Energy in eV</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(left_sigma, right_sigma) - Contact self-energies</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.integralCheck">
<span class="sig-name descname"><span class="pre">integralCheck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pauseFermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.integralCheck"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.integralCheck" title="Permalink to this definition"></a></dt>
<dd><p>Check and optimize integration parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for integration (default: 1e-4)</p></li>
<li><p><strong>cycles</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of SCF cycles to run (default: 10)</p></li>
<li><p><strong>damp</strong> (<em>float</em><em>, </em><em>optional</em>) – Damping parameter (default: 0.02)</p></li>
<li><p><strong>pauseFermi</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to pause Fermi updates (default: False)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.setContact1D">
<span class="sig-name descname"><span class="pre">setContact1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contactList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tauList</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stauList</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">betas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neList</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.setContact1D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.setContact1D" title="Permalink to this definition"></a></dt>
<dd><p>Set energy-dependent 1D chain contacts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contactList</strong> (<em>list</em>) – List of atom indices for contacts</p></li>
<li><p><strong>tauList</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Coupling matrices or atom indices (default: None)</p></li>
<li><p><strong>stauList</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Overlap matrices (default: None)</p></li>
<li><p><strong>alphas</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site energies (default: None)</p></li>
<li><p><strong>aOverlaps</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site overlaps (default: None)</p></li>
<li><p><strong>betas</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Hopping energies (default: None)</p></li>
<li><p><strong>bOverlaps</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Hopping overlaps (default: None)</p></li>
<li><p><strong>neList</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Number of electrons per unit cell (default: None)</p></li>
<li><p><strong>eta</strong> (<em>float</em><em>, </em><em>optional</em>) – Broadening parameter in eV (default: 1e-9)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Left and right contact orbital indices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.setContactBethe">
<span class="sig-name descname"><span class="pre">setContactBethe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contactList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latFile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Au'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.setContactBethe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.setContactBethe" title="Permalink to this definition"></a></dt>
<dd><p>Set energy-dependent Bethe lattice contacts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contactList</strong> (<em>list</em>) – List of atom indices for contacts</p></li>
<li><p><strong>latFile</strong> (<em>str</em><em>, </em><em>optional</em>) – Lattice parameter file (default: ‘Au’)</p></li>
<li><p><strong>eta</strong> (<em>float</em><em>, </em><em>optional</em>) – Broadening parameter in eV (default: 1e-9)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Left and right contact orbital indices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.setIntegralLimits">
<span class="sig-name descname"><span class="pre">setIntegralLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.setIntegralLimits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.setIntegralLimits" title="Permalink to this definition"></a></dt>
<dd><p>Set integration parameters for density calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N1</strong> (<em>int</em>) – Number of points for complex contour</p></li>
<li><p><strong>N2</strong> (<em>int</em>) – Number of points for real axis</p></li>
<li><p><strong>Emin</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Minimum energy for integration (default: None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.setSigma">
<span class="sig-name descname"><span class="pre">setSigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lContact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rContact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0</span> <span class="pre">-</span> <span class="pre">0.1j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.setSigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.setSigma" title="Permalink to this definition"></a></dt>
<dd><p>Set constant self-energy contacts with temperature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lContact</strong> (<em>list</em>) – Atom numbers for left contact, all atoms if None (default: None)</p></li>
<li><p><strong>rContact</strong> (<em>array-like</em>) – Atom numbers for right contact, all atoms if None (default: None)</p></li>
<li><p><strong>sig</strong> (<em>complex</em><em>, </em><em>optional</em>) – Left contact self-energy (default: -0.1j)</p></li>
<li><p><strong>sig2</strong> (<em>complex</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Right contact self-energy (default: None)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Left and right contact orbital indices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.scfE.NEGFE.setVoltage">
<span class="sig-name descname"><span class="pre">setVoltage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermiMethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'muller'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/scfE.html#NEGFE.setVoltage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.scfE.NEGFE.setVoltage" title="Permalink to this definition"></a></dt>
<dd><p>Set voltage bias and Fermi search method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qV</strong> (<em>float</em>) – Applied voltage in eV</p></li>
<li><p><strong>fermi</strong> (<em>float</em><em>, </em><em>optional</em>) – Fermi energy in eV (default: np.nan)</p></li>
<li><p><strong>Emin</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum energy for integration (default: None)</p></li>
<li><p><strong>Eminf</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum energy for Fermi search (default: None)</p></li>
<li><p><strong>fermiMethod</strong> (<em>str</em><em>, </em><em>optional</em>) – Method for Fermi search: ‘muller’, ‘secant’, or ‘predict’ (default: ‘muller’)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="density-module">
<h2>Density Module<a class="headerlink" href="#density-module" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.density"></span><p>Density matrix calculation methods for quantum transport simulations.</p>
<p>This module provides functions for calculating density matrices in quantum transport
calculations using various integration methods:</p>
<blockquote>
<div><ul class="simple">
<li><p>Analytical integration for energy-independent self-energies</p></li>
<li><p>Complex contour integration for equilibrium calculations</p></li>
<li><p>Real-axis integration for non-equilibrium calculations</p></li>
<li><p>Parallel processing support for large systems</p></li>
</ul>
</div></blockquote>
<p class="rubric">Notes</p>
<p>The module supports both serial and parallel computation modes, automatically
selecting the most efficient method based on system size and available resources.
Temperature effects are included through Fermi-Dirac statistics.</p>
<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.DOSg">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">DOSg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#DOSg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.DOSg" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density of states at given energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>E</strong> (<em>float</em>) – Energy in eV</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density of states at energy E</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.Gr">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">Gr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#Gr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.Gr" title="Permalink to this definition"></a></dt>
<dd><p>Calculate retarded Green’s function at given energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>E</strong> (<em>float</em>) – Energy in eV</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Retarded Green’s function G(E) = [ES - F - Σ(E)]^(-1)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarrayh</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.bisectFermi">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">bisectFermi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Gam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nexp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1000000.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#bisectFermi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.bisectFermi" title="Permalink to this definition"></a></dt>
<dd><p>Find Fermi energy using bisection method.</p>
<p>Uses bisection to find the Fermi energy that gives the expected number
of electrons. The search is performed using the analytical density matrix
calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<em>ndarray</em>) – Eigenvectors of Fock matrix in orthogonalized basis</p></li>
<li><p><strong>Vc</strong> (<em>ndarray</em>) – Inverse conjugate transpose of V</p></li>
<li><p><strong>D</strong> (<em>ndarray</em>) – Eigenvalues of Fock matrix</p></li>
<li><p><strong>Gam</strong> (<em>ndarray</em>) – Broadening matrix Γ = i[Σ - Σ†] in orthogonalized basis</p></li>
<li><p><strong>Nexp</strong> (<em>float</em>) – Expected number of electrons</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for electron number (default: 1e-3)</p></li>
<li><p><strong>Eminf</strong> (<em>float</em><em>, </em><em>optional</em>) – Lower bound for integration in eV (default: -1e6)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Fermi energy in eV that gives the expected electron count</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The search is bounded by the minimum and maximum eigenvalues.
Warns if maximum iterations reached without convergence.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.calcFermi">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">calcFermi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermiGuess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nOrbs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#calcFermi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.calcFermi" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi energy using bisection method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>ne</strong> (<em>float</em>) – Target number of electrons</p></li>
<li><p><strong>Emin</strong> (<em>float</em>) – Lower bound for complex contour in eV</p></li>
<li><p><strong>Emax</strong> (<em>float</em>) – Upper bound for search in eV</p></li>
<li><p><strong>fermiGuess</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial guess for Fermi energy in eV (default: 0)</p></li>
<li><p><strong>N1</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of complex contour points (default: 100)</p></li>
<li><p><strong>N2</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of real axis points (default: 50)</p></li>
<li><p><strong>Eminf</strong> (<em>float</em><em>, </em><em>optional</em>) – Lower bound for real axis integration in eV (default: -1e6)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence tolerance (default: 1e-4)</p></li>
<li><p><strong>maxcycles</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations (default: 20)</p></li>
<li><p><strong>nOrbs</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of orbitals to consider, 0 for all (default: 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(fermi, Emin, N1, N2) - Optimized parameters:
- fermi: Calculated Fermi energy in eV
- Emin: Lower bound for complex contour
- N1: Number of complex contour points
- N2: Number of real axis points</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.calcFermiBisect">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">calcFermiBisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#calcFermiBisect"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.calcFermiBisect" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi energy of system using bisection</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.calcFermiMuller">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">calcFermiMuller</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#calcFermiMuller"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.calcFermiMuller" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi energy using Muller’s method, starting with 3 initial points</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.calcFermiSecant">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">calcFermiSecant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#calcFermiSecant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.calcFermiSecant" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi energy using Secant method, updating dE at each step</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.density">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Gam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.density" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density matrix using analytical integration for energy-independent self-energies.</p>
<p>Implements the analytical integration method from Eq. 27 in PRB 65, 165401 (2002).
The method assumes energy-independent self-energies and uses the spectral function
representation of the density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<em>ndarray</em>) – Eigenvectors of Fock matrix in orthogonalized basis</p></li>
<li><p><strong>Vc</strong> (<em>ndarray</em>) – Inverse conjugate transpose of V</p></li>
<li><p><strong>D</strong> (<em>ndarray</em>) – Eigenvalues of Fock matrix</p></li>
<li><p><strong>Gam</strong> (<em>ndarray</em>) – Broadening matrix Γ = i[Σ - Σ†] in orthogonalized basis</p></li>
<li><p><strong>Emin</strong> (<em>float</em>) – Lower bound for integration in eV</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Chemical potential in eV</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density matrix in orthogonalized basis</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The integration is performed analytically using the residue theorem.
The result includes contributions from poles below the Fermi energy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.densityComplex">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">densityComplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numWorkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">showText</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ant'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#densityComplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.densityComplex" title="Permalink to this definition"></a></dt>
<dd><p>Calculate equilibrium density matrix using complex contour integration.</p>
<p>Performs numerical integration along a complex contour that encloses the
poles of the Fermi function. More efficient than real-axis integration
for equilibrium calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>Emin</strong> (<em>float</em>) – Lower bound for integration in eV</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Chemical potential in eV</p></li>
<li><p><strong>N</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of integration points (default: 100)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 300)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use parallel processing (default: False)</p></li>
<li><p><strong>numWorkers</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of worker processes for parallel mode</p></li>
<li><p><strong>showText</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print progress messages (default: True)</p></li>
<li><p><strong>method</strong> (<em>{'ant'</em><em>, </em><em>'legendre'</em><em>, </em><em>'chebyshev'}</em><em>, </em><em>optional</em>) – Integration method to use (default: ‘ant’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Equilibrium density matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘ant’ method uses a modified Gauss-Chebyshev quadrature optimized
for transport calculations, matching the ANT.Gaussian implementation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.densityComplexTrap">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">densityComplexTrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#densityComplexTrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.densityComplexTrap" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.densityGrid">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">densityGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numWorkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">showText</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#densityGrid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.densityGrid" title="Permalink to this definition"></a></dt>
<dd><p>Calculate non-equilibrium density matrix using real-axis integration.</p>
<p>Performs numerical integration for the non-equilibrium part of the density
matrix when a bias voltage is applied. Uses Gauss-Legendre quadrature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>mu1</strong> (<em>float</em>) – Left contact chemical potential in eV</p></li>
<li><p><strong>mu2</strong> (<em>float</em>) – Right contact chemical potential in eV</p></li>
<li><p><strong>ind</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Contact index (None for total) (default: None)</p></li>
<li><p><strong>N</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of integration points (default: 100)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 300)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use parallel processing (default: False)</p></li>
<li><p><strong>numWorkers</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of worker processes for parallel mode</p></li>
<li><p><strong>showText</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print progress messages (default: True)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Non-equilibrium contribution to density matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.densityGridTrap">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">densityGridTrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#densityGridTrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.densityGridTrap" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.densityReal">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">densityReal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numWorkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">showText</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#densityReal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.densityReal" title="Permalink to this definition"></a></dt>
<dd><p>Calculate equilibrium density matrix using real-axis integration.</p>
<p>Performs numerical integration along the real energy axis using Gauss-Legendre
quadrature. Suitable for equilibrium calculations with energy-dependent
self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>Emin</strong> (<em>float</em>) – Lower bound for integration in eV</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Chemical potential in eV</p></li>
<li><p><strong>N</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of integration points (default: 100)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 300)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use parallel processing (default: False)</p></li>
<li><p><strong>numWorkers</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of worker processes for parallel mode</p></li>
<li><p><strong>showText</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print progress messages (default: True)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.fermi">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">fermi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#fermi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.fermi" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi-Dirac distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy in eV</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Chemical potential in eV</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature in Kelvin</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Fermi-Dirac occupation number</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.getANTPoints">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">getANTPoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#getANTPoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.getANTPoints" title="Permalink to this definition"></a></dt>
<dd><p>Generate integration points and weights matching ANT.Gaussian implementation.</p>
<p>Follows the IntCompPlane subroutine in device.F90 from ANT.Gaussian package.
Uses a modified Gauss-Chebyshev quadrature scheme optimized for transport
calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>N</strong> (<em>int</em>) – Number of integration points</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(points, weights) - Arrays of integration points and weights</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.getFermi1DContact">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">getFermi1DContact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gSys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#getFermi1DContact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.getFermi1DContact" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi energy for a 1D chain contact.</p>
<p>Specialized version of getFermiContact for 1D chain contacts, handling
the periodic boundary conditions correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gSys</strong> (<em>surfG object</em>) – Surface Green’s function calculator for the full system</p></li>
<li><p><strong>ne</strong> (<em>float</em>) – Target number of electrons per unit cell</p></li>
<li><p><strong>ind</strong> (<em>int</em><em>, </em><em>optional</em>) – Contact index (0 for left, -1 for right) (default: 0)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence tolerance (default: 1e-4)</p></li>
<li><p><strong>Eminf</strong> (<em>float</em><em>, </em><em>optional</em>) – Lower bound for integration (default: -1e6)</p></li>
<li><p><strong>maxcycles</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations (default: 1000)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Fermi energy in eV</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.getFermiContact">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">getFermiContact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nOrbs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#getFermiContact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.getFermiContact" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi energy for a contact.</p>
<p>Determines the Fermi energy for a contact system (Bethe lattice or 1D chain)
by matching the electron count.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>ne</strong> (<em>float</em>) – Target number of electrons</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence tolerance (default: 1e-4)</p></li>
<li><p><strong>Eminf</strong> (<em>float</em><em>, </em><em>optional</em>) – Lower bound for integration (default: -1e6)</p></li>
<li><p><strong>maxcycles</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations (default: 1000)</p></li>
<li><p><strong>nOrbs</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of orbitals to consider (0 for all) (default: 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Fermi energy in eV</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.integralFit">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">integralFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#integralFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.integralFit" title="Permalink to this definition"></a></dt>
<dd><p>Optimize integration parameters for density calculations.</p>
<p>Determines optimal integration parameters by iteratively testing
convergence of the density matrix calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Equilibrium contact fermi energy in eV</p></li>
<li><p><strong>Eminf</strong> (<em>float</em>) – Lower bound for integration in eV (default: -1e6)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence tolerance (default: 1e-5)</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature in Kelvin for Fermi broadening (default: 0)</p></li>
<li><p><strong>maxN</strong> (<em>int</em><em>, </em><em>optional</em>) – Max grid points and Emin search iterations(default: 1000)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Emin, N1, N2) - Optimized integration parameters:
- Emin: Lower bound for complex contour
- N1: Number of complex contour points
- N2: Number of real axis points</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The optimization process:
1. Finds Emin by checking DOS convergence
2. Optimizes N1 for complex contour integration
3. Optimizes N2 for real axis integration</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.integralFitNEGF">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">integralFitNEGF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eminf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxGrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#integralFitNEGF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.integralFitNEGF" title="Permalink to this definition"></a></dt>
<dd><p>Determines number of  for non-equilibrium density calculations.</p>
<p>Same procedure as <cite>integralFit()</cite> but applied to <cite>densityGrid()</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>mu1</strong> (<em>float</em>) – Left contact Fermi energy in eV</p></li>
<li><p><strong>mu2</strong> (<em>float</em>) – Right contact Fermi energy in eV</p></li>
<li><p><strong>Eminf</strong> (<em>float</em>) – Lower bound for integration in eV (default: -1e6)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence tolerance (default: 1e-5)</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature in Kelvin for Fermi broadening (default: 0)</p></li>
<li><p><strong>maxGrid</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of gridpoints (default: 1000)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Number of grid points</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.density.integratePoints">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.density.</span></span><span class="sig-name descname"><span class="pre">integratePoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">computePointFunc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numWorkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunkSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/density.html#integratePoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.density.integratePoints" title="Permalink to this definition"></a></dt>
<dd><p>Perform parallel or serial integration for quantum transport calculations.</p>
<p>This function provides a flexible integration framework that automatically
chooses between numpy’s built-in parallelization for matrix operations
and process-level parallelization for large workloads.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>computePointFunc</strong> (<em>callable</em>) – Function that computes a single integration point. Should take an
integer index i and return a matrix/array.</p></li>
<li><p><strong>numPoints</strong> (<em>int</em>) – Total number of points to integrate</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to force process-level parallel processing (default: False)</p></li>
<li><p><strong>numWorkers</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of worker processes. If None, automatically determined based
on system resources and workload.</p></li>
<li><p><strong>chunkSize</strong> (<em>int</em><em>, </em><em>optional</em>) – Size of chunks for parallel processing. If None, automatically
optimized based on numPoints and numWorkers.</p></li>
<li><p><strong>debug</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print debug information (default: False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Sum of all computed points</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Automatically detects SLURM environment for HPC compatibility</p></li>
<li><p>Falls back to serial processing if parallel execution fails</p></li>
<li><p>Uses numpy’s built-in parallelization for small workloads</p></li>
<li><dl class="simple">
<dt>Switches to process-level parallelization for:</dt><dd><ul>
<li><p>Large number of points (≥100)</p></li>
<li><p>Many available cores (≥32)</p></li>
<li><p>When explicitly requested via parallel=True</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</section>
<section id="transport-module">
<h2>Transport Module<a class="headerlink" href="#transport-module" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.transport"></span><p>Transport calculations for quantum systems using Non-Equilibrium Green’s Functions.</p>
<p>This module provides functions for calculating quantum transport properties:
- Coherent transmission through molecular junctions
- Spin-dependent transport calculations
- Current calculations at finite bias
- Density of states calculations</p>
<p>The module supports both energy-independent and energy-dependent self-energies,
with implementations for both spin-restricted and spin-unrestricted calculations.
Spin-dependent transport follows the formalism described in [1].</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Herrmann, C., Solomon, G. C., &amp; Ratner, M. A. J. Chem. Theory Comput. 6, 3078 (2010)
DOI: 10.1021/acs.jctc.9b01078</p>
</aside>
</aside>
<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.DOS">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">DOS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Elist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#DOS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.DOS" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density of states with energy-independent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Elist</strong> (<em>array_like</em>) – List of energies in eV to calculate DOS at</p></li>
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix, NxN</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix, NxN</p></li>
<li><p><strong>sig1</strong> (<em>ndarray</em>) – Left contact self-energy, vector (1xN) or matrix (NxN)</p></li>
<li><p><strong>sig2</strong> (<em>ndarray</em>) – Right contact self-energy, vector (1xN) or matrix (NxN)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(DOS, DOSList) where:
- DOS: Total density of states at each energy
- DOSList: Site-resolved DOS at each energy</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.DOSE">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">DOSE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Elist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#DOSE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.DOSE" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density of states with energy-dependent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Elist</strong> (<em>array_like</em>) – List of energies in eV to calculate DOS at</p></li>
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(DOS, DOSList) where:
- DOS: Total density of states at each energy
- DOSList: Site-resolved DOS at each energy</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.cohTrans">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">cohTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Elist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#cohTrans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.cohTrans" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coherent transmission with energy-independent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Elist</strong> (<em>array_like</em>) – List of energies in eV to calculate transmission at</p></li>
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>sig1</strong> (<em>ndarray</em>) – Left contact self-energy (vector or matrix)</p></li>
<li><p><strong>sig2</strong> (<em>ndarray</em>) – Right contact self-energy (vector or matrix)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transmission values at each energy</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Supports both vector and matrix self-energies. For vector self-energies,
diagonal matrices are constructed internally.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.cohTransE">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">cohTransE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Elist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#cohTransE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.cohTransE" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coherent transmission with energy-dependent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Elist</strong> (<em>array_like</em>) – List of energies in eV to calculate transmission at</p></li>
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transmission values at each energy</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses the surface Green’s function calculator to compute energy-dependent
self-energies at each energy point.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.cohTransSpin">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">cohTransSpin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Elist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'u'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#cohTransSpin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.cohTransSpin" title="Permalink to this definition"></a></dt>
<dd><p>Calculate spin-dependent coherent transmission with energy-independent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Elist</strong> (<em>array_like</em>) – List of energies in eV to calculate transmission at</p></li>
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix (2N x 2N for spin-unrestricted)</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix (2N x 2N for spin-unrestricted)</p></li>
<li><p><strong>sig1</strong> (<em>ndarray</em>) – <dl class="simple">
<dt>Left contact self-energy (spin independent vector (1xN) or matrix (NxN),</dt><dd><p>spin dependent matrix (2Nx2N))</p>
</dd>
</dl>
</p></li>
<li><p><strong>sig2</strong> (<em>ndarray</em>) – <dl class="simple">
<dt>Right contact self-energy (spin independent vector (1xN) or matrix (NxN),</dt><dd><p>spin dependent matrix (2Nx2N))</p>
</dd>
</dl>
</p></li>
<li><p><strong>spin</strong> (<em>str</em><em>, </em><em>optional</em>) – Spin basis {‘r’, ‘u’, ‘ro’, or ‘g’} (default: ‘u’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Tr, Tspin) where:
- Tr: Total transmission at each energy
- Tspin: Array of spin-resolved transmissions [T↑↑, T↑↓, T↓↑, T↓↓]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For collinear spin calculations (‘u’ or ‘ro’), the matrices are arranged in blocks:
[F↑↑  0 ]  [S↑↑  0 ]
[0   F↓↓], [0   S↓↓]
For generalized spin basis (‘g’), each orbital contains a 2x2 spinor block:
[F↑↑  F↑↓]  [S↑↑  S↑↓]
[F↓↑  F↓↓], [S↓↑  S↓↓]
which are then combined into a 2Nx2N matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.cohTransSpinE">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">cohTransSpinE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Elist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'u'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#cohTransSpinE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.cohTransSpinE" title="Permalink to this definition"></a></dt>
<dd><p>Calculate spin-dependent coherent transmission with energy-dependent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Elist</strong> (<em>array_like</em>) – List of energies in eV to calculate transmission at</p></li>
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>spin</strong> (<em>str</em><em>, </em><em>optional</em>) – Spin basis {‘r’, ‘u’, ‘ro’, or ‘g’} (default: ‘u’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Tr, Tspin) where:
- Tr: Total transmission at each energy
- Tspin: Array of spin-resolved transmissions [T↑↑, T↑↓, T↓↑, T↓↓]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.current">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">current</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#current"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.current" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coherent current using NEGF with energy-independent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>sig1</strong> (<em>ndarray</em>) – Left contact self-energy (vector or matrix)</p></li>
<li><p><strong>sig2</strong> (<em>ndarray</em>) – Right contact self-energy (vector or matrix)</p></li>
<li><p><strong>fermi</strong> (<em>float</em>) – Fermi energy in eV</p></li>
<li><p><strong>qV</strong> (<em>float</em>) – Applied bias voltage in eV</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature in Kelvin (default: 0)</p></li>
<li><p><strong>spin</strong> (<em>str</em><em>, </em><em>optional</em>) – Spin configuration (‘r’ for restricted) (default: ‘r’)</p></li>
<li><p><strong>dE</strong> (<em>float</em><em>, </em><em>optional</em>) – Energy step for integration in eV (default: 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Current in Amperes</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.currentE">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">currentE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#currentE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.currentE" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coherent current at T=0K using NEGF with energy-dependent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>g</strong> (<em>surfG object</em>) – Surface Green’s function calculator</p></li>
<li><p><strong>fermi</strong> (<em>float</em>) – Fermi energy in eV</p></li>
<li><p><strong>qV</strong> (<em>float</em>) – Applied bias voltage in eV</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature in Kelvin (default: 0)</p></li>
<li><p><strong>spin</strong> (<em>str</em><em>, </em><em>optional</em>) – Spin configuration (‘r’ for restricted) (default: ‘r’)</p></li>
<li><p><strong>dE</strong> (<em>float</em><em>, </em><em>optional</em>) – Energy step for integration in eV (default: 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Current in Amperes</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.currentF">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">currentF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#currentF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.currentF" title="Permalink to this definition"></a></dt>
<dd><p>Calculate current from saved SCF matrix file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<em>str</em>) – Filename of .mat file containing SCF data</p></li>
<li><p><strong>dE</strong> (<em>float</em><em>, </em><em>optional</em>) – Energy step for integration in eV (default: 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Current in Amperes</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The .mat file should contain:
- F: Fock matrix
- S: Overlap matrix
- sig1, sig2: Contact self-energies
- fermi: Fermi energy
- qV: Applied voltage
- spin: Spin configuration</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.transport.currentSpin">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.transport.</span></span><span class="sig-name descname"><span class="pre">currentSpin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fermi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/transport.html#currentSpin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.transport.currentSpin" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coherent spin current using NEGF with energy-independent self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>sig1</strong> (<em>ndarray</em>) – Left contact self-energy (vector or matrix)</p></li>
<li><p><strong>sig2</strong> (<em>ndarray</em>) – Right contact self-energy (vector or matrix)</p></li>
<li><p><strong>fermi</strong> (<em>float</em>) – Fermi energy in eV</p></li>
<li><p><strong>qV</strong> (<em>float</em>) – Applied bias voltage in eV</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature in Kelvin (default: 0)</p></li>
<li><p><strong>spin</strong> (<em>str</em><em>, </em><em>optional</em>) – Spin configuration (‘r’ for restricted) (default: ‘r’)</p></li>
<li><p><strong>dE</strong> (<em>float</em><em>, </em><em>optional</em>) – Energy step for integration in eV (default: 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Spin-currents (in Amperes) [I↑↑, I↑↓, I↓↑, I↓↓]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="contact-models">
<h1>Contact Models<a class="headerlink" href="#contact-models" title="Permalink to this heading"></a></h1>
<section id="bethe-lattice">
<h2>Bethe Lattice<a class="headerlink" href="#bethe-lattice" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.surfGBethe"></span><p>Surface Green’s function implementation for Bethe lattice contacts.</p>
<p>This module provides a Bethe lattice implementation for modeling semi-infinite
metallic contacts in quantum transport calculations. It supports:
- FCC [111] surface geometry with proper orbital symmetries
- Slater-Koster parameterization for s, p, and d orbitals
- Temperature-dependent calculations
- Spin-restricted and unrestricted calculations</p>
<p>The implementation follows the ANT.Gaussian approach [1], using a minimal basis
set with s, p, and d orbitals for each contact atom. The Bethe lattice model
provides an efficient way to describe bulk metallic electrodes while maintaining
proper orbital symmetries and electronic structure. This approach allows for
accurate modeling of metal-molecule interfaces without the computational cost
of explicit periodic boundary conditions.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Jacob, D., &amp; Palacios, J. J. (2011). Critical comparison of electrode models</dt><dd><p>in density functional theory based quantum transport calculations.
The Journal of Chemical Physics, 134(4), 044118.
DOI: 10.1063/1.3526044</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gauNEGF.surfGBethe.</span></span><span class="sig-name descname"><span class="pre">surfGB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contacts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latFile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Au'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Surface Green’s function calculator for Bethe lattice contacts.</p>
<p>This class implements the Bethe lattice approximation for modeling
semi-infinite metallic contacts. It handles:
- Contact geometry detection and setup
- Slater-Koster parameter management
- Energy-dependent self-energy calculations
- Temperature effects
- Spin configurations</p>
<p>The Bethe lattice model represents the contacts as a semi-infinite tree-like
structure with proper coordination number and orbital symmetries matching
those of bulk FCC metals. This provides an efficient way to compute surface
Green’s functions and self-energies for the electrodes, as demonstrated by
Jacob &amp; Palacios in their 2011 paper [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix</p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – Overlap matrix</p></li>
<li><p><strong>contacts</strong> (<em>list</em><em> of </em><em>lists</em>) – List of atom indices for each contact</p></li>
<li><p><strong>bar</strong> (<em>object</em>) – Gaussian interface object containing basis set information</p></li>
<li><p><strong>latFile</strong> (<em>str</em><em>, </em><em>optional</em>) – Filename for Bethe lattice parameters (default: ‘Au’)</p></li>
<li><p><strong>spin</strong> (<em>str</em><em>, </em><em>optional</em>) – Spin configuration (‘r’ for restricted) (default: ‘r’)</p></li>
<li><p><strong>eta</strong> (<em>float</em><em>, </em><em>optional</em>) – Broadening parameter in eV (default: 1e-9)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 0)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.cVecs">
<span class="sig-name descname"><span class="pre">cVecs</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.cVecs" title="Permalink to this definition"></a></dt>
<dd><p>Normal vectors for each contact surface</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.latVecs">
<span class="sig-name descname"><span class="pre">latVecs</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.latVecs" title="Permalink to this definition"></a></dt>
<dd><p>Lattice vectors for each contact</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.indsLists">
<span class="sig-name descname"><span class="pre">indsLists</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.indsLists" title="Permalink to this definition"></a></dt>
<dd><p>Orbital indices for each contact atom</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.dirLists">
<span class="sig-name descname"><span class="pre">dirLists</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.dirLists" title="Permalink to this definition"></a></dt>
<dd><p>Direction vectors for nearest neighbors</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.nIndLists">
<span class="sig-name descname"><span class="pre">nIndLists</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.nIndLists" title="Permalink to this definition"></a></dt>
<dd><p>Nearest neighbor indices for each atom</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.gList">
<span class="sig-name descname"><span class="pre">gList</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.gList" title="Permalink to this definition"></a></dt>
<dd><p>surfGBAt objects for each contact</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Jacob, D., &amp; Palacios, J. J. (2011). Critical comparison of electrode models</dt><dd><p>in density functional theory based quantum transport calculations.
The Journal of Chemical Physics, 134(4), 044118.
DOI: 10.1063/1.3526044</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.constructMat">
<span class="sig-name descname"><span class="pre">constructMat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mdict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirCosines</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.constructMat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.constructMat" title="Permalink to this definition"></a></dt>
<dd><p>Construct hopping/overlap matrix using Slater-Koster formalism.</p>
<p>Builds a 9x9 matrix for s, p, and d orbital interactions based on the
Slater-Koster two-center approximation. The matrix is first constructed
assuming a [0,0,1] bond direction, then rotated to the given direction
using direction cosines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mdict</strong> (<em>dict</em>) – Dictionary of Slater-Koster parameters (ssσ, spσ, ppσ, etc.)</p></li>
<li><p><strong>dirCosines</strong> (<em>ndarray</em>) – Array [l,m,n] of direction cosines for the bond</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>9x9 matrix containing orbital interactions in the rotated frame</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Matrix blocks:
- [0,0]: s-s interaction
- [0:4,0:4]: s-p block
- [0:4,4:9]: s-d and p-d blocks
- [4:9,4:9]: d-d block</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.genNeighbors">
<span class="sig-name descname"><span class="pre">genNeighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane_normal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_neighbor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.genNeighbors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.genNeighbors" title="Permalink to this definition"></a></dt>
<dd><p>Generate 12 nearest neighbor unit vectors for an FCC [111] surface.</p>
<p>Creates a list of unit vectors representing the 12 nearest neighbors in an FCC lattice:
- 6 in-plane vectors forming a hexagonal pattern (3 pairs of opposite vectors)
- 6 out-of-plane vectors forming triangular patterns (3 pairs of opposite vectors)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_normal</strong> (<em>ndarray</em>) – Vector normal to the crystal plane (will be normalized)</p></li>
<li><p><strong>first_neighbor</strong> (<em>ndarray</em>) – Vector to one nearest neighbor (will be projected onto plane)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>12 unit vectors representing nearest neighbor directions</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.getSigma">
<span class="sig-name descname"><span class="pre">getSigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Elist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.getSigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.getSigma" title="Permalink to this definition"></a></dt>
<dd><p>Helper method for getting the left and right contact self-energies</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Elist</strong> (<em>tuple</em><em>, </em><em>optional</em>) – A list of contact energies for selecting sigma,
(default: use contact ermi energy)</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterial for the self-energy matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of both self-energy matrices (ndarrays)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.readBetheParams">
<span class="sig-name descname"><span class="pre">readBetheParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.readBetheParams"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.readBetheParams" title="Permalink to this definition"></a></dt>
<dd><p>Read Slater-Koster parameters from a .bethe file.</p>
<p>Reads and validates parameters for minimal basis with single s, p, and d orbitals.
Parameters are stored in dictionaries for onsite energies, hopping integrals,
and overlap matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – Name of the .bethe file (without extension)</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If parameters are missing or invalid</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters are sorted into:
- Edict: Onsite energies (converted from Hartrees to eV)
- Vdict: Hopping parameters (converted from Hartrees to eV)
- Sdict: Overlap parameters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.runAllTests">
<span class="sig-name descname"><span class="pre">runAllTests</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.runAllTests"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.runAllTests" title="Permalink to this definition"></a></dt>
<dd><p>Run all validation tests for surfGB.</p>
<p>Executes all test methods to validate:
- d orbital angular functions
- d orbital symmetry
- p-d interactions
- d-d interactions
- General hopping physics</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.setF">
<span class="sig-name descname"><span class="pre">setF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">muL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">muR</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.setF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.setF" title="Permalink to this definition"></a></dt>
<dd><p>Update Fock matrix and contact chemical potentials.</p>
<p>Sets the Fock matrix and updates the Fermi levels of the left and
right contacts if they have changed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – New Fock matrix</p></li>
<li><p><strong>muL</strong> (<em>float</em>) – Chemical potential for left contact in eV</p></li>
<li><p><strong>muR</strong> (<em>float</em>) – Chemical potential for right contact in eV</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.sigma">
<span class="sig-name descname"><span class="pre">sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.sigma" title="Permalink to this definition"></a></dt>
<dd><p>Calculate self-energy matrix for a specific contact.</p>
<p>Computes the self-energy matrix for contact i by:
1. Calculating surface self-energies for all 9 directions
2. Summing contributions from directions not connected to the device
3. Applying de-orthonormalization if needed
4. Handling spin configurations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point for self-energy calculation (in eV)</p></li>
<li><p><strong>i</strong> (<em>int</em>) – Index of the contact to calculate self-energy for</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for self-energy calculation (default: 1e-5)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Self-energy matrix for the specified contact, with dimensions:
- (N, N) for restricted calculations
- (2N, 2N) for unrestricted or generalized spin calculations</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Jacob, D., &amp; Palacios, J. J. (2011). Critical comparison of electrode models</dt><dd><p>in density functional theory based quantum transport calculations.
The Journal of Chemical Physics, 134(4), 044118.
DOI: 10.1063/1.3526044</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.sigmaTot">
<span class="sig-name descname"><span class="pre">sigmaTot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.sigmaTot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.sigmaTot" title="Permalink to this definition"></a></dt>
<dd><p>Calculate total self-energy matrix for the extended system.</p>
<p>Computes self-energies for all sites in the extended system (12 neighbors + 1 center).
The total self-energy is constructed following the Bethe lattice model described in
Jacob &amp; Palacios [1], which provides an efficient representation of bulk metallic
electrodes while maintaining proper orbital symmetries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point for Green’s function calculation (in eV)</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for self-energy calculation (default: 1e-5)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Total self-energy matrix for the extended system</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Jacob, D., &amp; Palacios, J. J. (2011). Critical comparison of electrode models</dt><dd><p>in density functional theory based quantum transport calculations.
The Journal of Chemical Physics, 134(4), 044118.
DOI: 10.1063/1.3526044</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.testDDInteraction">
<span class="sig-name descname"><span class="pre">testDDInteraction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.testDDInteraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.testDDInteraction" title="Permalink to this definition"></a></dt>
<dd><p>Test d-d orbital interactions.</p>
<p>Validates d-d orbital interactions by checking:
- dyz-dyz interaction along x-axis (should be pure delta)
- dz2-dz2 interaction along z-axis (should be pure sigma)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.testDOrbitalFunctions">
<span class="sig-name descname"><span class="pre">testDOrbitalFunctions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.testDOrbitalFunctions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.testDOrbitalFunctions" title="Permalink to this definition"></a></dt>
<dd><p>Test d orbital angular functions.</p>
<p>Validates the angular dependence of d orbital interactions by checking:
- dxy interaction along x-axis (should be zero)
- dx2-y2 interaction along x-axis (should be sqrt(3)/2 * sds)
- dz2 interaction along x-axis (should be -1/2 * sds)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.testDOrbitalSymmetry">
<span class="sig-name descname"><span class="pre">testDOrbitalSymmetry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.testDOrbitalSymmetry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.testDOrbitalSymmetry" title="Permalink to this definition"></a></dt>
<dd><p>Test d orbital symmetry properties.</p>
<p>Validates that d orbital interactions respect inversion symmetry
by comparing interactions along opposite directions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.testHoppingPhysics">
<span class="sig-name descname"><span class="pre">testHoppingPhysics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.testHoppingPhysics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.testHoppingPhysics" title="Permalink to this definition"></a></dt>
<dd><p>Test physical properties of hopping matrices.</p>
<p>Validates hopping matrix physics by checking:
- s-p hopping antisymmetry
- Conservation of total s-p hopping magnitude
- Proper angular dependence along principal axes and 45-degree rotations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.testPDInteraction">
<span class="sig-name descname"><span class="pre">testPDInteraction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.testPDInteraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.testPDInteraction" title="Permalink to this definition"></a></dt>
<dd><p>Test p-d orbital interactions.</p>
<p>Validates p-d orbital interactions by checking:
- px-dxy interaction along x-axis (should be zero)
- pz-dz2 interaction along z-axis (should be pure sigma)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGB.updateFermi">
<span class="sig-name descname"><span class="pre">updateFermi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGB.updateFermi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGB.updateFermi" title="Permalink to this definition"></a></dt>
<dd><p>Update Fermi energy for a specific contact.</p>
<p>Shifts the Hamiltonian of contact i to align its Fermi level with
the specified energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> (<em>int</em>) – Contact index</p></li>
<li><p><strong>Ef</strong> (<em>float</em>) – New Fermi energy in eV</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gauNEGF.surfGBethe.</span></span><span class="sig-name descname"><span class="pre">surfGBAt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Slist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Atomic-level Bethe lattice Green’s function calculator.</p>
<p>This class implements the surface Green’s function calculation for a single atom
in the Bethe lattice, handling:
- Onsite and hopping matrix construction
- Self-energy calculations for bulk and surface
- Temperature effects
- Fermi energy optimization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>ndarray</em>) – Onsite Hamiltonian matrix (9x9 for minimal basis)</p></li>
<li><p><strong>Slist</strong> (<em>list</em><em> of </em><em>ndarray</em>) – List of 12 overlap matrices for nearest neighbors</p></li>
<li><p><strong>Vlist</strong> (<em>list</em><em> of </em><em>ndarray</em>) – List of 12 hopping matrices for nearest neighbors</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – Broadening parameter in eV</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 0)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.NN">
<span class="sig-name descname"><span class="pre">NN</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.NN" title="Permalink to this definition"></a></dt>
<dd><p>Number of nearest neighbors (fixed to 12 for FCC)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.sigmaKprev">
<span class="sig-name descname"><span class="pre">sigmaKprev</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.sigmaKprev" title="Permalink to this definition"></a></dt>
<dd><p>Previous bulk self-energy for convergence</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.Eprev">
<span class="sig-name descname"><span class="pre">Eprev</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.Eprev" title="Permalink to this definition"></a></dt>
<dd><p>Previous energy point for convergence</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.fermi">
<span class="sig-name descname"><span class="pre">fermi</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.fermi" title="Permalink to this definition"></a></dt>
<dd><p>Current Fermi energy</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.F">
<span class="sig-name descname"><span class="pre">F</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.F" title="Permalink to this definition"></a></dt>
<dd><p>Extended Fock matrix including neighbors</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.S">
<span class="sig-name descname"><span class="pre">S</span></span><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.S" title="Permalink to this definition"></a></dt>
<dd><p>Extended overlap matrix including neighbors</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.DOS">
<span class="sig-name descname"><span class="pre">DOS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.DOS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.DOS" title="Permalink to this definition"></a></dt>
<dd><p>Calculate bulk density of states of the Bethe lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>E</strong> (<em>float</em>) – Energy point for DOS calculation (in eV)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density of states at energy E</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Slist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize surfGBAt with Hamiltonian and neighbor matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>ndarray</em>) – Onsite Hamiltonian matrix (9x9 for minimal basis)</p></li>
<li><p><strong>Slist</strong> (<em>list</em><em> of </em><em>ndarray</em>) – List of 12 overlap matrices for nearest neighbors</p></li>
<li><p><strong>Vlist</strong> (<em>list</em><em> of </em><em>ndarray</em>) – List of 12 hopping matrices for nearest neighbors</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – Broadening parameter in eV</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 0)</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If matrix dimensions are incorrect or number of neighbors != 12</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.calcFermi">
<span class="sig-name descname"><span class="pre">calcFermi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fGuess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.calcFermi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.calcFermi" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Fermi energy using bisection method.</p>
<p>Uses getFermiContact from density.py to find the Fermi energy that gives
the correct number of electrons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ne</strong> (<em>float</em>) – Target number of electrons</p></li>
<li><p><strong>fGuess</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial guess for Fermi energy in eV (default: 5)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence tolerance (default: 1e-5)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Calculated Fermi energy in eV</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Previous implementation used ANT.Gaussian approach with complex contour
integration. Current version uses simpler bisection method from density.py.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.setF">
<span class="sig-name descname"><span class="pre">setF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.setF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.setF" title="Permalink to this definition"></a></dt>
<dd><p>Empty function for compatibility with density.py methods.</p>
<p>Bethe lattice bulk properties are intrinsic (dependent on TB parameters).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – Fock matrix (unused)</p></li>
<li><p><strong>mu1</strong> (<em>float</em>) – First chemical potential (unused)</p></li>
<li><p><strong>mu2</strong> (<em>float</em>) – Second chemical potential (unused)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.sigma">
<span class="sig-name descname"><span class="pre">sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.sigma" title="Permalink to this definition"></a></dt>
<dd><p>Calculate surface self-energies for an FCC lattice.</p>
<p>Computes self-energies for atoms at the surface with the geometry:
[3x plane dir] - o - [3x plane dir]</p>
<blockquote>
<div><blockquote>
<div><p>/<a href="#id7"><span class="problematic" id="id8">|</span></a></p>
</div></blockquote>
<p>[3x out of plane dir]</p>
</div></blockquote>
<p>Uses a self-consistent iteration scheme with mixing to solve the Dyson equation.
The implementation follows the Bethe lattice approach described in Jacob &amp; Palacios (2011),
where the self-energy is computed recursively for a semi-infinite tree-like structure
that preserves the proper coordination number and orbital symmetries of bulk FCC metals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point for Green’s function calculation (in eV)</p></li>
<li><p><strong>inds</strong> (<em>list</em><em> or </em><em>int</em><em>, </em><em>optional</em>) – Indices of the sigma matrix to return. If None, returns full list (default: None)</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for Dyson equation (default: 1e-5)</p></li>
<li><p><strong>mix</strong> (<em>float</em><em>, </em><em>optional</em>) – Mixing factor for Dyson equation (default: 0.5)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of self-energy matrices for the surface atom. If inds is specified,
returns only the requested matrices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>First calculates bulk self-energies using sigmaK, then iterates to find
surface self-energies for the 9 surface directions. The recursive method
ensures proper treatment of the metal-molecule interface while maintaining
computational efficiency.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Jacob, D., &amp; Palacios, J. J. (2011). Critical comparison of electrode models</dt><dd><p>in density functional theory based quantum transport calculations.
The Journal of Chemical Physics, 134(4), 044118.
DOI: 10.1063/1.3526044</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.sigmaK">
<span class="sig-name descname"><span class="pre">sigmaK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.sigmaK"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.sigmaK" title="Permalink to this definition"></a></dt>
<dd><p>Calculate bulk self-energies for all 12 lattice directions.</p>
<dl>
<dt>Computes self-energies for an FCC lattice with the following geometry:</dt><dd><dl class="simple">
<dt>[3x out of plane dir]</dt><dd><p>|/</p>
</dd>
</dl>
</dd>
<dt>[3x plane dir] - o - [3x plane dir]</dt><dd><blockquote>
<div><p>/<a href="#id9"><span class="problematic" id="id10">|</span></a></p>
</div></blockquote>
<p>[3x out of plane dir]</p>
</dd>
</dl>
<p>Uses a self-consistent iteration scheme with mixing to solve the Dyson equation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point for Green’s function calculation (in eV)</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for Dyson equation (default: 1e-5)</p></li>
<li><p><strong>mix</strong> (<em>float</em><em>, </em><em>optional</em>) – Mixing factor for Dyson equation (default: 0.5)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of 12 self-energy matrices (9x9 each) in order by lattice direction</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses previous solution as initial guess when energy point is close to
previous calculation to improve convergence.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.sigmaTot">
<span class="sig-name descname"><span class="pre">sigmaTot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.sigmaTot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.sigmaTot" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGBethe.surfGBAt.updateH">
<span class="sig-name descname"><span class="pre">updateH</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGBethe.html#surfGBAt.updateH"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGBethe.surfGBAt.updateH" title="Permalink to this definition"></a></dt>
<dd><p>Update Hamiltonian and extended matrices.</p>
<p>Updates onsite and hopping matrices, as well as extended lattice matrices.
The extended matrices H0x and S0x include 13 sites total (12 neighbor sites
followed by 1 onsite term). These are stored as F and S for compatibility
with density.py functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fermi</strong> (<em>float</em><em>, </em><em>optional</em>) – New Fermi energy setpoint in eV (default: None)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When fermi is provided and different from current value:
- Shifts onsite energies by the Fermi level difference
- Updates hopping matrices with overlap contributions
- Rebuilds extended matrices for the full system</p>
</dd></dl>

</dd></dl>

</section>
<section id="d-chain">
<h2>1D Chain<a class="headerlink" href="#d-chain" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.surfG1D"></span><p>Surface Green’s function implementation for 1D chain contacts.</p>
<p>This module provides a 1D chain implementation for modeling semi-infinite
contacts in quantum transport calculations. It supports three usage patterns:</p>
<ol class="loweralpha">
<li><p>Fully automatic extraction from Fock matrix:
surfG1D(F, S, [[contact1], [contact2]], [[contact1connection], [contact2connection]])
- All parameters extracted from F/S using contact and connection indices</p></li>
<li><p>Fock matrix with custom coupling:
surfG1D(F, S, [[contact1], [contact2]], [tau1, tau2], [stau1, stau2])
- Contact parameters from F/S, but with custom coupling matrices</p></li>
<li><p>Fully specified contacts:
surfG1D(F, S, [[contact1], [contact2]], [tau1, tau2], [stau1, stau2],</p>
<blockquote>
<div><p>[alpha1, alpha2], [salpha1, salpha2], [beta1, beta2], [sbeta1, sbeta2])</p>
</div></blockquote>
<ul class="simple">
<li><p>All contact parameters specified manually</p></li>
</ul>
</li>
</ol>
<p>The implementation uses an iterative scheme to calculate surface Green’s
functions for 1D chain contacts, with support for both manual parameter
specification and automatic extraction from DFT calculations.</p>
<dl class="py class">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gauNEGF.surfG1D.</span></span><span class="sig-name descname"><span class="pre">surfG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Overlap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indsList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">staus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">betas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Surface Green’s function calculator for 1D chain contacts.</p>
<p>This class implements the surface Green’s function calculation for 1D chain
contacts. It supports three usage patterns:</p>
<ol class="loweralpha">
<li><p>Fully automatic extraction from Fock matrix:
- Provide contact indices and connection indices
- All parameters extracted from F/S matrices
Example: surfG1D(F, S, [[c1], [c2]], [[c1conn], [c2conn]])</p></li>
<li><p>Fock matrix with custom coupling:
- Provide contact indices and coupling matrices
- Onsite contact parameters from F/S, coupling specified manually
Example: surfG1D(F, S, [[c1], [c2]], [tau1, tau2], [stau1, stau2])</p></li>
<li><p>Fully specified contacts:
- All contact parameters provided manually
Example: surfG1D(F, S, [[c1], [c2]], [tau1, tau2], [stau1, stau2],</p>
<blockquote>
<div><p>[alpha1, alpha2], [salpha1, salpha2], [beta1, beta2], [sbeta1, sbeta2])</p>
</div></blockquote>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Fock</strong> (<em>ndarray</em>) – Fock matrix for the extended system</p></li>
<li><p><strong>Overlap</strong> (<em>ndarray</em>) – Overlap matrix for the extended system</p></li>
<li><p><strong>indsList</strong> (<em>list</em><em> of </em><em>lists</em>) – Lists of orbital indices for each contact region</p></li>
<li><p><strong>taus</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Either coupling matrices or connection indices (default: None)
- If indices: [[contact1connection], [contact2connection]]
- If matrices: [tau1, tau2]</p></li>
<li><p><strong>staus</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Overlap matrices for coupling, required if taus are matrices (default: None)</p></li>
<li><p><strong>alphas</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site energies for contacts, required for pattern (c) (default: None)</p></li>
<li><p><strong>aOverlaps</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site overlap matrices for contacts, required for pattern (c) (default: None)</p></li>
<li><p><strong>betas</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Hopping matrices between contact unit cells, required for pattern (c) (default: None)</p></li>
<li><p><strong>bOverlaps</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Overlap matrices between contact unit cells, required for pattern (c) (default: None)</p></li>
<li><p><strong>eta</strong> (<em>float</em><em>, </em><em>optional</em>) – Broadening parameter in eV (default: 1e-9)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.F">
<span class="sig-name descname"><span class="pre">F</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.F" title="Permalink to this definition"></a></dt>
<dd><p>Fock matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.S">
<span class="sig-name descname"><span class="pre">S</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.S" title="Permalink to this definition"></a></dt>
<dd><p>Overlap matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.X">
<span class="sig-name descname"><span class="pre">X</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.X" title="Permalink to this definition"></a></dt>
<dd><p>Inverse square root of overlap matrix for orthogonalization</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.tauList">
<span class="sig-name descname"><span class="pre">tauList</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.tauList" title="Permalink to this definition"></a></dt>
<dd><p>Contact coupling matrices</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.stauList">
<span class="sig-name descname"><span class="pre">stauList</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.stauList" title="Permalink to this definition"></a></dt>
<dd><p>Contact coupling overlap matrices</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.aList">
<span class="sig-name descname"><span class="pre">aList</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.aList" title="Permalink to this definition"></a></dt>
<dd><p>On-site energy matrices for contacts</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.aSList">
<span class="sig-name descname"><span class="pre">aSList</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.aSList" title="Permalink to this definition"></a></dt>
<dd><p>On-site overlap matrices for contacts</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.bList">
<span class="sig-name descname"><span class="pre">bList</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.bList" title="Permalink to this definition"></a></dt>
<dd><p>Hopping matrices between contact unit cells</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.bSList">
<span class="sig-name descname"><span class="pre">bSList</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.bSList" title="Permalink to this definition"></a></dt>
<dd><p>Overlap matrices between contact unit cells</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.gPrev">
<span class="sig-name descname"><span class="pre">gPrev</span></span><a class="headerlink" href="#gauNEGF.surfG1D.surfG.gPrev" title="Permalink to this definition"></a></dt>
<dd><p>Previous surface Green’s functions for convergence</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Overlap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indsList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">staus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">betas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize the surface Green’s function calculator.</p>
<p>The initialization follows one of three patterns:
a) Fully automatic: Only provide Fock, Overlap, indsList, and connection indices in taus
b) Custom coupling: Provide Fock, Overlap, indsList, coupling matrices in taus, and staus
c) Fully specified: Provide all parameters including alphas, aOverlaps, betas, bOverlaps</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Fock</strong> (<em>ndarray</em>) – Fock matrix for the extended system</p></li>
<li><p><strong>Overlap</strong> (<em>ndarray</em>) – Overlap matrix for the extended system</p></li>
<li><p><strong>indsList</strong> (<em>list</em><em> of </em><em>lists</em>) – Lists of orbital indices for each contact region</p></li>
<li><p><strong>taus</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Either coupling matrices or connection indices (default: None)
- If indices: [[contact1connection], [contact2connection]]
- If matrices: [tau1, tau2]</p></li>
<li><p><strong>staus</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Overlap matrices for coupling, required if taus are matrices (default: None)</p></li>
<li><p><strong>alphas</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site energies for contacts, required for pattern (c) (default: None)</p></li>
<li><p><strong>aOverlaps</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site overlap matrices for contacts, required for pattern (c) (default: None)</p></li>
<li><p><strong>betas</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Hopping matrices between contact unit cells, required for pattern (c) (default: None)</p></li>
<li><p><strong>bOverlaps</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Overlap matrices between contact unit cells, required for pattern (c) (default: None)</p></li>
<li><p><strong>eta</strong> (<em>float</em><em>, </em><em>optional</em>) – Broadening parameter in eV (default: 1e-9)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The initialization will raise an error if:
- The parameters don’t match one of the three usage patterns
- taus contains matrices but staus is None
- alphas is provided but aOverlaps is None
- betas is provided but bOverlaps is None</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.denFunc">
<span class="sig-name descname"><span class="pre">denFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.denFunc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.denFunc" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density matrix contribution at a single energy point.</p>
<p>Computes the contribution to the density matrix at energy E for
specified orbitals. This is used by integration routines to
calculate the total density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point in eV</p></li>
<li><p><strong>ind</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Contact index for partial density calculation (default: None)</p></li>
<li><p><strong>mu</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Chemical potential in eV (default: None)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 300)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density matrix contribution at energy E</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.densityGrid">
<span class="sig-name descname"><span class="pre">densityGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Emin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.densityGrid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.densityGrid" title="Permalink to this definition"></a></dt>
<dd><p>Calculate density matrix contribution on a grid of energy points.</p>
<p>Computes the contribution to the density matrix for each energy
point in a grid from Emin to Emax. This is used for real-axis
integration of the density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Emin</strong> (<em>float</em>) – Minimum energy for integration in eV</p></li>
<li><p><strong>Emax</strong> (<em>float</em>) – Maximum energy for integration in eV</p></li>
<li><p><strong>ind</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Contact index for partial density calculation (default: None)</p></li>
<li><p><strong>dE</strong> (<em>float</em><em>, </em><em>optional</em>) – Energy step size in eV (default: 0.001)</p></li>
<li><p><strong>mu</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Chemical potential in eV (default: None)</p></li>
<li><p><strong>T</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature in Kelvin (default: 300)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of density matrix contributions at each energy point</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.g">
<span class="sig-name descname"><span class="pre">g</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relFactor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.g"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.g" title="Permalink to this definition"></a></dt>
<dd><p>Calculate surface Green’s function for a contact.</p>
<p>Uses an iterative scheme to calculate the surface Green’s function
for contact i at energy E. The iteration continues until the change
in the Green’s function is below the convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point in eV</p></li>
<li><p><strong>i</strong> (<em>int</em>) – Contact index</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for iteration (default: 1e-5)</p></li>
<li><p><strong>relFactor</strong> (<em>float</em><em>, </em><em>optional</em>) – Relaxation factor for iteration mixing (default: 0.1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Surface Green’s function matrix for contact i</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method uses the previous solution as an initial guess to improve
convergence. For the first calculation at a given energy, it uses
zeros as the initial guess. The relaxation factor controls mixing
between iterations to help convergence.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.setContacts">
<span class="sig-name descname"><span class="pre">setContacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">betas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bOverlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.setContacts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.setContacts" title="Permalink to this definition"></a></dt>
<dd><p>Update contact parameters for the 1D chain.</p>
<p>This method is used internally during initialization and can be called
later to update contact parameters. It follows the same patterns as
initialization:</p>
<ol class="loweralpha simple">
<li><p>If self.contactFromFock is True (patterns a and b):
- Parameters are extracted from F/S matrices
- Any provided parameters are ignored</p></li>
<li><p>If self.contactFromFock is False (pattern c):
- All parameters must be provided together
- Partial updates are not supported</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alphas</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site energies for contacts (default: None)</p></li>
<li><p><strong>aOverlaps</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – On-site overlap matrices for contacts (default: None)</p></li>
<li><p><strong>betas</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Hopping matrices between contact unit cells (default: None)</p></li>
<li><p><strong>bOverlaps</strong> (<em>list</em><em> of </em><em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Overlap matrices between contact unit cells (default: None)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When using pattern (c), all parameters must be provided together.
Partial updates (providing some parameters but not others) are not
supported and will raise an error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.setF">
<span class="sig-name descname"><span class="pre">setF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.setF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.setF" title="Permalink to this definition"></a></dt>
<dd><p>Update the Fock matrix and contact chemical potentials.</p>
<p>This method updates the system’s Fock matrix and optionally shifts
the contact chemical potentials. If the contacts are extracted from
the Fock matrix, their parameters are automatically updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>ndarray</em>) – New Fock matrix for the system</p></li>
<li><p><strong>mu1</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Chemical potential for first contact in eV (default: None)</p></li>
<li><p><strong>mu2</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Chemical potential for second contact in eV (default: None)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If chemical potentials are provided, the corresponding contact
parameters are shifted to align with the new potentials.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.sigma">
<span class="sig-name descname"><span class="pre">sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.sigma" title="Permalink to this definition"></a></dt>
<dd><p>Calculate self-energy matrix for a contact.</p>
<p>Computes the self-energy matrix for contact i at energy E using
the surface Green’s function. The self-energy represents the
effect of the semi-infinite contact on the device region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point in eV</p></li>
<li><p><strong>i</strong> (<em>int</em>) – Contact index</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for surface Green’s function (default: 1e-5)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Self-energy matrix for contact i</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfG1D.surfG.sigmaTot">
<span class="sig-name descname"><span class="pre">sigmaTot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfG1D.html#surfG.sigmaTot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfG1D.surfG.sigmaTot" title="Permalink to this definition"></a></dt>
<dd><p>Calculate total self-energy matrix from all contacts.</p>
<p>Computes the total self-energy matrix at energy E by summing
contributions from all contacts. This represents the combined
effect of all semi-infinite contacts on the device region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<em>float</em>) – Energy point in eV</p></li>
<li><p><strong>conv</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for surface Green’s functions (default: 1e-5)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Total self-energy matrix from all contacts</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="constant-self-energy">
<h2>Constant Self Energy<a class="headerlink" href="#constant-self-energy" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.surfGTester"></span><dl class="py class">
<dt class="sig sig-object py" id="gauNEGF.surfGTester.surfGTest">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gauNEGF.surfGTester.</span></span><span class="sig-name descname"><span class="pre">surfGTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Overlap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indsList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGTester.html#surfGTest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGTester.surfGTest" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGTester.surfGTest.setF">
<span class="sig-name descname"><span class="pre">setF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGTester.html#surfGTest.setF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGTester.surfGTest.setF" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGTester.surfGTest.sigma">
<span class="sig-name descname"><span class="pre">sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGTester.html#surfGTest.sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGTester.surfGTest.sigma" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gauNEGF.surfGTester.surfGTest.sigmaTot">
<span class="sig-name descname"><span class="pre">sigmaTot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/surfGTester.html#surfGTest.sigmaTot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.surfGTester.surfGTest.sigmaTot" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>
<section id="utilities">
<h1>Utilities<a class="headerlink" href="#utilities" title="Permalink to this heading"></a></h1>
<section id="matrix-tools">
<h2>Matrix Tools<a class="headerlink" href="#matrix-tools" title="Permalink to this heading"></a></h2>
<span class="target" id="module-gauNEGF.matTools"></span><p>Matrix manipulation utilities for quantum transport calculations.</p>
<p>This module provides helper functions for handling matrices in quantum transport
calculations, with a focus on:
- Self-energy matrix construction
- Density and Fock matrix manipulation
- Spin treatment (restricted, unrestricted, and generalized)
- Integration with Gaussian’s matrix formats</p>
<p>The functions handle three types of spin treatments:
- ‘r’: Restricted (same orbitals for alpha and beta electrons)
- ‘ro’/’u’: Unrestricted (separate alpha and beta orbitals)
- ‘g’: Generalized (non-collinear spin treatment)</p>
<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.matTools.formSigma">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.matTools.</span></span><span class="sig-name descname"><span class="pre">formSigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsto</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/matTools.html#formSigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.matTools.formSigma" title="Permalink to this definition"></a></dt>
<dd><p>Form a self-energy matrix for specified orbitals.</p>
<p>Creates a self-energy matrix of size nsto x nsto with values V
at the specified orbital indices. Can handle both scalar and
matrix-valued self-energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inds</strong> (<em>list</em><em> of </em><em>int</em>) – Orbital indices where self-energy should be applied</p></li>
<li><p><strong>V</strong> (<em>complex</em><em> or </em><em>ndarray</em>) – Self-energy value(s) to insert
- If scalar: Same value used for all specified orbitals
- If matrix: Must match size of indices</p></li>
<li><p><strong>nsto</strong> (<em>int</em>) – Total number of orbitals (size of resulting matrix)</p></li>
<li><p><strong>S</strong> (<em>ndarray</em><em> or </em><em>int</em><em>, </em><em>optional</em>) – Overlap matrix for broadening term. If 0, identity used (default: 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Complex self-energy matrix of size nsto x nsto</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.matTools.getDen">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.matTools.</span></span><span class="sig-name descname"><span class="pre">getDen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/matTools.html#getDen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.matTools.getDen" title="Permalink to this definition"></a></dt>
<dd><p>Build density matrix from Gaussian checkpoint file.</p>
<p>Extracts the density matrix from a Gaussian checkpoint file based on
the specified spin treatment. Handles restricted, unrestricted, and
generalized cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bar</strong> (<em>QCBinAr</em>) – Gaussian interface object</p></li>
<li><p><strong>spin</strong> (<em>str</em>) – Spin treatment to use:
- ‘r’: Restricted (same orbitals for alpha/beta)
- ‘ro’/’u’: Unrestricted (separate alpha/beta)
- ‘g’: Generalized (non-collinear)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density matrix in appropriate format for spin treatment:
- Restricted: Single block
- Unrestricted: Two blocks (alpha/beta)
- Generalized: Single block with complex entries</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If spin treatment is not recognized</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.matTools.getEnergies">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.matTools.</span></span><span class="sig-name descname"><span class="pre">getEnergies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/matTools.html#getEnergies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.matTools.getEnergies" title="Permalink to this definition"></a></dt>
<dd><p>Get orbital energies from Gaussian checkpoint file.</p>
<p>Extracts orbital energies from a Gaussian checkpoint file based on
the specified spin treatment. Converts energies from Hartrees to eV.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bar</strong> (<em>QCBinAr</em>) – Gaussian interface object</p></li>
<li><p><strong>spin</strong> (<em>str</em>) – Spin treatment to use:
- ‘r’: Restricted (same orbitals for alpha/beta)
- ‘ro’/’u’: Unrestricted (separate alpha/beta)
- ‘g’: Generalized (non-collinear)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of orbital energies in eV, sorted in ascending order.
Format depends on spin treatment:
- Restricted: Alternating alpha/beta pairs
- Unrestricted: Alternating alpha/beta pairs
- Generalized: Single set of energies</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If spin treatment is not recognized</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.matTools.getFock">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.matTools.</span></span><span class="sig-name descname"><span class="pre">getFock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/matTools.html#getFock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.matTools.getFock" title="Permalink to this definition"></a></dt>
<dd><p>Build Fock matrix from Gaussian checkpoint file.</p>
<p>Extracts the Fock matrix and orbital indices from a Gaussian checkpoint
file based on the specified spin treatment. Handles restricted,
unrestricted, and generalized cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bar</strong> (<em>QCBinAr</em>) – Gaussian interface object</p></li>
<li><p><strong>spin</strong> (<em>str</em>) – Spin treatment to use:
- ‘r’: Restricted (same orbitals for alpha/beta)
- ‘ro’/’u’: Unrestricted (separate alpha/beta)
- ‘g’: Generalized (non-collinear)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>(Fock, locs) where:
- Fock: ndarray, Fock matrix in appropriate format for spin treatment
- locs: ndarray, Orbital indices with positive for alpha/paired and</p>
<blockquote>
<div><p>negative for beta orbitals</p>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If spin treatment is not recognized</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gauNEGF.matTools.storeDen">
<span class="sig-prename descclassname"><span class="pre">gauNEGF.matTools.</span></span><span class="sig-name descname"><span class="pre">storeDen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gauNEGF/matTools.html#storeDen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gauNEGF.matTools.storeDen" title="Permalink to this definition"></a></dt>
<dd><p>Store density matrix in Gaussian checkpoint format.</p>
<p>Converts the density matrix to the appropriate format based on spin
treatment and stores it in the Gaussian checkpoint file. Handles
compression and proper typing of matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bar</strong> (<em>QCBinAr</em>) – Gaussian interface object</p></li>
<li><p><strong>P</strong> (<em>ndarray</em>) – Density matrix to store</p></li>
<li><p><strong>spin</strong> (<em>str</em>) – Spin treatment to use:
- ‘r’: Restricted (same orbitals for alpha/beta)
- ‘ro’/’u’: Unrestricted (separate alpha/beta)
- ‘g’: Generalized (non-collinear)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For restricted calculations, the density is divided by 2 to account
for double occupation. For generalized calculations, complex matrices
are used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If spin treatment is not recognized</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../examples/index.html" class="btn btn-neutral float-left" title="Examples and Tutorials" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>